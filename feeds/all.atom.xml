<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>abarker.github.io</title><link href="https://abarker.github.io/" rel="alternate"></link><link href="https://abarker.github.io/feeds/all.atom.xml" rel="self"></link><id>https://abarker.github.io/</id><updated>2019-07-22T12:13:00-04:00</updated><entry><title>Setting Up Spellchecking in Vim</title><link href="https://abarker.github.io/setting_up_vim_spellchecking/" rel="alternate"></link><published>2019-07-16T14:13:00-04:00</published><updated>2019-07-16T14:13:00-04:00</updated><author><name>Allen Barker</name></author><id>tag:abarker.github.io,2019-07-16:/setting_up_vim_spellchecking/</id><summary type="html">&lt;p class="first last"&gt;Short instructions for setting up Vim for&amp;nbsp;spellchecking.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;These are short instructions for setting up the Vim or Gvim editor to do spellchecking.
A Unix-type shell is&amp;nbsp;assumed.&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;Create a subdirectory of your &lt;tt class="docutils literal"&gt;.vim&lt;/tt&gt; directory to hold the local
dictionary of new&amp;nbsp;words:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mkdir -p ~/.vim/spell
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Add the following lines to your &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;~/.vimrc&lt;/span&gt;&lt;/tt&gt; file.  Change the &lt;tt class="docutils literal"&gt;en&lt;/tt&gt; parts if you
are spellchecking some language other than&amp;nbsp;English:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
set spelllang=en
set spellfile=$HOME/.vim/spell/en.utf-8.add
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;After these steps Vim is set up for spellchecking.  Open a text file in Vim.  Now these
commands are&amp;nbsp;available:&lt;/p&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="27%" /&gt;
&lt;col width="73%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;Command&lt;/th&gt;
&lt;th class="head"&gt;Action&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;:setlocal spell&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;Turn on spellchecking.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;:set nospell&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;Turn off spellchecking.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;]s&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;Goto next misspelled word.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;[s&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;Goto previous misspelled word.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;zg&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;Add the current &amp;#8220;good&amp;#8221; word to your local dictionary.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;z=&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;Suggest spellings (choose a number or hit enter for none).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;zw&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;Mark the current word as wrong.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;zug&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;Remove the current word from your local dictionary.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;The misspelled words should be highlighted when spellchecking is turned&amp;nbsp;on.&lt;/p&gt;
</content><category term="vim"></category><category term="editor"></category><category term="linux"></category></entry><entry><title>Understanding Python Imports</title><link href="https://abarker.github.io/understanding_python_imports/" rel="alternate"></link><published>2019-07-12T14:13:00-04:00</published><updated>2019-07-22T12:13:00-04:00</updated><author><name>Allen Barker</name></author><id>tag:abarker.github.io,2019-07-12:/understanding_python_imports/</id><summary type="html">&lt;p class="first last"&gt;Description of modern Python&amp;nbsp;imports.&lt;/p&gt;
</summary><content type="html">
&lt;p&gt;Python has many strong points and tends to have a learning curve that is
friendly to beginners.  The import system, however, is one part of the
language which can be confusing.  There are a few possible sources of confusion:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Certain import statements which work for modules inside packages do not work
for modules outside of packages, and vice versa.&lt;/li&gt;
&lt;li&gt;Modules run as scripts have some special properties which can affect imports.&lt;/li&gt;
&lt;li&gt;Lack of familiarity with the Python package mechanism in general.&lt;/li&gt;
&lt;li&gt;Some of the import syntax does not generalize in the way one might first
expect it does.&lt;/li&gt;
&lt;li&gt;Old documentation can come up in searches.  (For example, Python 2 had
something called implicit relative import which Python 3 does not have.  If
you’re still using Python 2, disable implicit relative imports by using &lt;code&gt;from
__future__ import absolute_import&lt;/code&gt; as the first import.)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This article only discusses modern Python imports (Python versions &amp;gt;3.0).
Basic familiarity with the concepts of files and directories/folders is
assumed.  Before imports are discussed Python modules and packages will be
briefly reviewed.&lt;/p&gt;
&lt;div class="section" id="review-of-python-modules-and-packages"&gt;
&lt;h2&gt;1. &lt;a class="toc-backref" href="#id2"&gt;Review of Python modules and packages&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;At some point most non-trivial projects become large enough that it makes sense
to separate the code into separate files.  In Python those separate files are
called &lt;strong&gt;modules&lt;/strong&gt;.  The use of modules can make the codebase easier to
understand and, as the name implies, more modular.  Imports are used to allow
code in one module to access and use code from other modules.&lt;/p&gt;
&lt;p&gt;The Python module and package system is closely tied to the directories and
files in the underlying filesystem.  Understanding the correspondence is
important in understanding the Python import system.  The basic correspondence
can be summarized as follows:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\textrm{files with}\; \texttt{.py}\; \textrm{extension} \;\Longrightarrow\; \textrm{python modules} \\
\end{align*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{align*}
\substack{\textrm{directory subtrees where each} \\
\textrm{directory has an}\; \texttt{__init__.py}\; \textrm{file}} \;\Longrightarrow\; \textrm{python packages} \\
\end{align*}
&lt;/div&gt;
&lt;p&gt;A file containing Python code is always a module and vice versa. The filename
of a module should end with the &lt;code&gt;.py&lt;/code&gt; extension.  The name of a Python module
is the same as its filename without the &lt;code&gt;.py&lt;/code&gt; extension (except for modules run
directly as scripts; those are generally not imported and are always named
&lt;code&gt;__main__&lt;/code&gt;, see &lt;a class="reference internal" href="#section5"&gt;Section 5&lt;/a&gt;).  All Python programs are composed of
one or more modules.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Packages&lt;/strong&gt; are collections of modules organized in a certain way:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Any Python module which is inside a directory containing an &lt;code&gt;__init__.py&lt;/code&gt;
file (which may or may not be an empty file) is by definition part of the
package associated with that &lt;code&gt;__init__.py&lt;/code&gt; file.  The name of the package is
the same as the name of the directory.  (Formally, packages are just a
special kind of module, but in this context packages and modules will be
considered to be distinct.)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Subpackages&lt;/strong&gt; are defined similarly to packages, as subdirectories of a
package directory which also contain an &lt;code&gt;__init__.py&lt;/code&gt; file.  Subpackages can
have their own subpackages, and so forth.&lt;/li&gt;
&lt;li&gt;A module with no &lt;code&gt;__init__.py&lt;/code&gt; in its directory is not part of any package or
subpackage (excepting namespace packages, an advanced topic briefly discussed
&lt;a class="reference internal" href="#namespace-packages"&gt;later&lt;/a&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Consider this example directory structure, which will be used throughout the article:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
my_project
│
├── bin
│   └── my_script.py
│
└── src
    ├── my_standalone_module.py
    │
    └── my_package
        ├── __init__.py
        ├── foo.py
        ├── bar.py
        │
        └── my_subpackage
            ├── __init__.py
            └── baz.py
&lt;/pre&gt;
&lt;p&gt;This is the skeleton of a project called &lt;code&gt;my_project&lt;/code&gt; which contains one script
called &lt;code&gt;my_script&lt;/code&gt; in its &lt;code&gt;bin&lt;/code&gt; directory and a package called &lt;code&gt;my_package&lt;/code&gt; in
its &lt;code&gt;src&lt;/code&gt; directory.  (Some people prefer not to have a separate &lt;code&gt;src&lt;/code&gt;
directory, but there are some &lt;a class="reference external" href="https://hynek.me/articles/testing-packaging/"&gt;good&lt;/a&gt; &lt;a class="reference external" href="https://blog.ionelmc.ro/2014/05/25/python-packaging/"&gt;reasons&lt;/a&gt; to include it.)  There
is also a module named &lt;code&gt;my_standalone_module&lt;/code&gt; in the &lt;code&gt;src&lt;/code&gt; directory.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;__init__.py&lt;/code&gt; files in the directories are essentially the modules for the
corresponding packages or subpackages.  When a module is imported its code
is run to initialize it.  When a package or subpackage is
imported its &lt;code&gt;__init__.py&lt;/code&gt; is implicitly imported and run.&lt;/p&gt;
&lt;p&gt;A package’s namespace is by definition the namespace of the &lt;code&gt;__init__.py&lt;/code&gt;
module in its directory.  This includes any names which are explicitly imported
into the &lt;code&gt;__init__.py&lt;/code&gt; file.  Whenever a subpackage of a package is imported
its name is automatically added to the namespace of the parent package (i.e. to
the namespace of that package’s &lt;code&gt;__init__.py&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Subpackages are imported (and their &lt;code&gt;__init__.py&lt;/code&gt; files are run) when they are
either 1) explicitly imported or 2) automatically imported just before a module
or subpackage contained within that subpackage is imported.  As noted above,
the &lt;code&gt;module&lt;/code&gt; object representing the subpackage is also added to the namespace
of the package or subpackage that imports it (under its subpackage name).&lt;/p&gt;
&lt;p&gt;It is easy to underestimate &lt;code&gt;__init__.py&lt;/code&gt; files, since they are often empty
files, but they are quite important as far as how Python packages work.  The
top-level namespace of a package constitutes its main application-programmer
interface (&lt;span class="caps"&gt;API&lt;/span&gt;).  Names which should be exposed by that &lt;span class="caps"&gt;API&lt;/span&gt; need to be imported
into the &lt;code&gt;__init__.py&lt;/code&gt; file.&lt;/p&gt;
&lt;p&gt;Python &lt;code&gt;import&lt;/code&gt; statements always contain a specifier for a package or module
to import.  Equivalently, they always contain a specifier for the corresponding
file or a directory in the filesystem.  Remember that while Python’s import
statements never use the &lt;code&gt;.py&lt;/code&gt; file extension for naming modules, other than
that the names of modules, packages, and subpackages generally correspond
directly with filesystem objects (files and directories) and their filesystem names.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-python-path-search-list-sys-path"&gt;
&lt;h2&gt;2. &lt;a class="toc-backref" href="#id3"&gt;The Python path-search list: &lt;code&gt;sys.path&lt;/code&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;sys.path&lt;/code&gt; list is the root of all imports in Python (excepting system
library modules such as &lt;code&gt;math&lt;/code&gt;, which are always found in their usual
location).  This list tells the Python import system where to look for packages
and modules to import.  It is just a list containing directory pathnames,
represented as strings.&lt;/p&gt;
&lt;p&gt;All standard, non-library imports have the &lt;code&gt;sys.path&lt;/code&gt; list at their root:  &lt;strong&gt;A
standalone module cannot be imported if its containing directory is not on
the&lt;/strong&gt; &lt;code&gt;sys.path&lt;/code&gt; &lt;strong&gt;list, and a package cannot be imported if the parent
directory of its top-level directory (the parent of the top directory
containing an&lt;/strong&gt; &lt;code&gt;__init__.py&lt;/code&gt; &lt;strong&gt;file) is not on the&lt;/strong&gt; &lt;code&gt;sys.path&lt;/code&gt; &lt;strong&gt;list.&lt;/strong&gt; Note
that when external packages are installed with &lt;code&gt;pip&lt;/code&gt; or similar programs they
are placed in the system &lt;code&gt;site-packages&lt;/code&gt; directory, which is on &lt;code&gt;sys.path&lt;/code&gt; by
default.  That is what allows them to be discovered and imported.&lt;/p&gt;
&lt;p&gt;Ordering in the &lt;code&gt;sys.path&lt;/code&gt; list is important: The first match found in the list
is the one that is used.  The paths themselves are strings which can represent
relative or absolute pathnames for the underlying operating system.  Any
relative pathnames in &lt;code&gt;sys.path&lt;/code&gt; (such as &lt;code&gt;".."&lt;/code&gt;) are interpreted relative to
Python’s current working directory (&lt;span class="caps"&gt;CWD&lt;/span&gt;).  The &lt;span class="caps"&gt;CWD&lt;/span&gt; is initially set to the
command shell’s notion of current directory, i.e., the directory you are in
when you invoke the &lt;code&gt;python&lt;/code&gt; command.  The Python &lt;span class="caps"&gt;CWD&lt;/span&gt; can be changed by calls to
&lt;code&gt;os.setcwd()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Directories can be added to the initial &lt;code&gt;sys.path&lt;/code&gt; list from command shells
like Bash by setting the &lt;code&gt;PYTHONPATH&lt;/code&gt; environment variable before invoking the
&lt;code&gt;python&lt;/code&gt; command.  The &lt;code&gt;PYTHONPATH&lt;/code&gt; environment variable should contain a
colon-separated string of the pathnames to be added.  While this has its uses,
it is usually not the recommended way to initialize &lt;code&gt;sys.path&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The command to import a package which is located in a directory on the
&lt;code&gt;sys.path&lt;/code&gt; list is simple: just import the package name (which is the name of
its top-level directory).  Similarly, to import a non-package module located in
a directory on &lt;code&gt;sys.path&lt;/code&gt; just import the module’s name (which is the filename
leaving off the &lt;code&gt;.py&lt;/code&gt; extension).  For example, suppose the path to directory
&lt;code&gt;my_project/src&lt;/code&gt; in the skeleton project above is in the &lt;code&gt;sys.path&lt;/code&gt; list.  Then
the following imports work:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;my_package&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;my_standalone_module&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The first statement imports the package &lt;code&gt;my_package&lt;/code&gt; in the directory of that
same name, and the second statement import the module &lt;code&gt;my_standalone_module&lt;/code&gt;
with code located in the file &lt;code&gt;my_standalone_module.py&lt;/code&gt;.  The same imports can
be done with a single statement, although that style of import is not generally recommended:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;my_package&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nn"&gt;my_standalone_module&lt;/span&gt; &lt;span class="c1"&gt;# Same as above two imports.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What is actually being imported here are two &lt;code&gt;module&lt;/code&gt; objects, one representing
the package &lt;code&gt;my_package&lt;/code&gt; and the other representing the module &lt;code&gt;my_module&lt;/code&gt;.
For example, if you run &lt;code&gt;str(type(my_package))&lt;/code&gt; after the above import the
result is &lt;code&gt;"&amp;lt;class 'module'&amp;gt;"&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;All the names in the namespace of a package or module represented by a &lt;code&gt;module&lt;/code&gt;
object are also attributes of that &lt;code&gt;module&lt;/code&gt; object (i.e., they are in its
&lt;code&gt;__dict__&lt;/code&gt;).  This is what allows those attributes to be accessed directly from
the imported module objects.  For example, suppose the &lt;code&gt;__init__.py&lt;/code&gt; of
&lt;code&gt;my_package&lt;/code&gt; defines the variable &lt;code&gt;init_var&lt;/code&gt; and &lt;code&gt;my_standalone_module&lt;/code&gt; defines
the variable &lt;code&gt;my_standalone_module_var&lt;/code&gt;.  Then expressions like
&lt;code&gt;my_package.init_var&lt;/code&gt; and &lt;code&gt;my_standalone_module.my_standalone_module_var&lt;/code&gt; can
be used to access those variables in any module that makes the above imports.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;as&lt;/code&gt; keyword can optionally be used to rename an import under an alias:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;my_package&lt;/span&gt; &lt;span class="kn"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;mp&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;my_standalone_module&lt;/span&gt; &lt;span class="kn"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;msm&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;my_package&lt;/span&gt; &lt;span class="kn"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;mp&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nn"&gt;my_standalone_module&lt;/span&gt; &lt;span class="kn"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;msm&lt;/span&gt; &lt;span class="c1"&gt;# Same as above two.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;as&lt;/code&gt; keyword can be used in any import statement to change the name under
which the import is saved in the local namespace.  It only renames the local
reference, not the actual name of the module.&lt;/p&gt;
&lt;p&gt;Python always keeps a cache of imported packages and modules as &lt;code&gt;module&lt;/code&gt;
objects in the &lt;code&gt;sys.modules&lt;/code&gt; dict, keyed by the fully-qualified name of the
package or module.  When an import statement is executed Python first looks in
that dict to see if the package or module has previously been imported.  If so
it returns the previously-imported object.  Otherwise it tries to import from
the filesystem.  Re-importing a module requires the explicit use of the builtin
&lt;code&gt;reload&lt;/code&gt; function.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;from&lt;/code&gt; statement can be used to import subpackages as well as to import
particular attributes defined in a package or module:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;my_package&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;init_var&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;iv&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;my_subpackage&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;msp&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;my_standalone_module&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;my_standalone_module_var&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The first of these statements imports the attribute &lt;code&gt;init_var&lt;/code&gt; from the package
namespace of &lt;code&gt;my_package&lt;/code&gt;, renaming it as &lt;code&gt;iv&lt;/code&gt;.  It also imports the subpackage
&lt;code&gt;my_subpackage&lt;/code&gt;, renamed to &lt;code&gt;msp&lt;/code&gt;.  The second statement imports the attribute
&lt;code&gt;my_standalone_module_var&lt;/code&gt; from &lt;code&gt;my_standalone_module&lt;/code&gt; with no renaming.&lt;/p&gt;
&lt;p&gt;Imports using the &lt;code&gt;from&lt;/code&gt; keyword will be referred to as &lt;code&gt;from&lt;/code&gt; imports, and
imports without the &lt;code&gt;from&lt;/code&gt; keyword will be referred to as bare &lt;code&gt;import&lt;/code&gt;
statements.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="absolute-imports"&gt;
&lt;h2&gt;3. &lt;a class="toc-backref" href="#id4"&gt;Absolute imports&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;We have already seen one kind of absolute import, which is the import of a
module or package from a directory on the &lt;code&gt;sys.path&lt;/code&gt; list.  There is one more
kind of absolute import which has not yet been covered.  These are used to
import modules and subpackages which are located inside packages.  That kind of
import cannot be done correctly simply by placing the directory on &lt;code&gt;sys.path&lt;/code&gt;
and then importing the module or subpackage.  (In fact, a package directory or
subdirectory, i.e., a directory with an &lt;code&gt;__init__.py&lt;/code&gt; file, should &lt;em&gt;never&lt;/em&gt;
appear in the &lt;code&gt;sys.path&lt;/code&gt; list.  Doing that can introduce subtle bugs which can
be difficult to find.  Only the &lt;em&gt;parent&lt;/em&gt; directory of the top-level package
directory should ever appear in &lt;code&gt;sys.path&lt;/code&gt;.)&lt;/p&gt;
&lt;p&gt;Absolute imports can always be used, in any Python module, regardless of
whether it is inside a package or outside of a package.  Absolute imports
&lt;em&gt;require&lt;/em&gt; that the directory containing either the top-level package directory
or the non-package module being imported be discoverable on the &lt;code&gt;sys.path&lt;/code&gt;
list.&lt;/p&gt;
&lt;p&gt;Absolute imports for modules inside packages use a dotted-path syntax.  For example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;my_package.foo&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This statement imports the module &lt;code&gt;foo&lt;/code&gt;, located in the file
&lt;code&gt;my_package/foo.py&lt;/code&gt;.  After this import the &lt;code&gt;foo&lt;/code&gt; module is accessible under
the name &lt;code&gt;my_package.foo&lt;/code&gt;.  An &lt;code&gt;as&lt;/code&gt; keyword could have been used to create an
alias, if desired.  The next subsection covers the syntax of these dotted paths
and their relation to the files and directories of the filesystem.  Once dotted
paths are understood absolute imports will be much easier to discuss.&lt;/p&gt;
&lt;div class="section" id="absolute-dotted-paths-and-the-filesystem"&gt;
&lt;h3&gt;3.1. &lt;a class="toc-backref" href="#id5"&gt;Absolute dotted paths and the filesystem&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;For any package which can be discovered by looking in the directories on the
&lt;code&gt;sys.path&lt;/code&gt; list there is a corresponding &lt;strong&gt;dotted path&lt;/strong&gt; to specify modules
(files) and subpackages (subdirectories) located inside the package (inside the
package’s directory subtree).  The slashes in operating-system pathnames are
essentially replaced with dots.  These dotted paths are always relative to the
package’s top-level directory (i.e., the highest-level directory containing an
&lt;code&gt;__init__.py&lt;/code&gt; file),&lt;/p&gt;
&lt;p&gt;Here are some examples of the correspondence, based on the project skeleton
above.  The filesystem pathnames are given on the left (assuming forward
slashes), and the corresponding dotted paths are on the right:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\scriptstyle\texttt{src/my_package} \;\Longrightarrow\; \texttt{mypackage} \\
\end{align*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{align*}
\scriptstyle\texttt{src/my_package/foo.py} \;\Longrightarrow\; \texttt{mypackage.foo} \\
\end{align*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{align*}
\scriptstyle\texttt{src/my_package/my_subpackage} \;\Longrightarrow\; \texttt{mypackage.my_subpackage} \\
\end{align*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
\scriptstyle\texttt{src/my_package/my_subpackage/baz.py} \;\Longrightarrow\; \texttt{mypackage.my_subpackage.baz}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;Note that the &lt;code&gt;.py&lt;/code&gt; extension is omitted, but other than that the
correspondence is fairly simple.  In an import statement these dotted paths
&lt;em&gt;always&lt;/em&gt; refer to objects on the filesystem.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="absolute-imports-of-subpackages-and-modules-in-packages"&gt;
&lt;h3&gt;3.2. &lt;a class="toc-backref" href="#id6"&gt;Absolute imports of subpackages and modules in packages&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Now that dotted paths have been covered the discussion of importing modules
that are inside packages is fairly simple: just put the dotted path after the
&lt;code&gt;import&lt;/code&gt; or &lt;code&gt;from&lt;/code&gt; statement.  The first component of the dotted path for an
absolute import is &lt;em&gt;always&lt;/em&gt; the top-level package name (i.e., the name of the
top-level directory of the package subtree).&lt;/p&gt;
&lt;p&gt;For package &lt;code&gt;my_package&lt;/code&gt; in the skeleton given earlier these are all valid bare
&lt;code&gt;import&lt;/code&gt; statements:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;my_package&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;my_package.foo&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;my_package.my_subpackage&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;my_package.my_subpackage.baz&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Each of these imports results in a &lt;code&gt;module&lt;/code&gt; object in the namespace which, when
used in an expression, syntactically matches the dotted path in the import
statement.  The syntax looks the same but in an expression the dots are
attribute accesses on &lt;code&gt;module&lt;/code&gt; objects.  For example, the second import does
not actually add anything to the namespace of the module doing the import.  The
module for &lt;code&gt;my_package&lt;/code&gt; is already in the namespace due to the first import.
The second import just adds the module attribute &lt;code&gt;foo&lt;/code&gt; to the &lt;code&gt;my_package&lt;/code&gt;
namespace so that &lt;code&gt;my_package.foo&lt;/code&gt; works in expressions.&lt;/p&gt;
&lt;p&gt;This is a general property of bare &lt;code&gt;import&lt;/code&gt; statements: After a bare &lt;code&gt;import&lt;/code&gt;
without an &lt;code&gt;as&lt;/code&gt; the dotted-path used to make the import is always usable in
Python expressions in the importing module.  But in those expressions the dot
symbol represents attribute access, unlike in the import statement itself.
This is discussed further in the next subsection.&lt;/p&gt;
&lt;p&gt;Python uses its &lt;code&gt;sys.modules&lt;/code&gt; cache for dotted-path imports, too.  It goes down
the names on the dotted path and if it finds one that has not previously been
imported then it imports the remainder of the dotted path from the filesystem.
Any previously-imported packages or modules are taken from the cache.&lt;/p&gt;
&lt;p&gt;Imports using &lt;code&gt;from&lt;/code&gt; also work for dotted paths.  The imports below are all
valid imports from the example package &lt;code&gt;my_package&lt;/code&gt;.  They correspond to the
imports above (except the first one above, which has no corresponding &lt;code&gt;from&lt;/code&gt;
import).  After a &lt;code&gt;from&lt;/code&gt; import, though, only the package or module following
the &lt;code&gt;import&lt;/code&gt; keyword is added to the namespace of the importing module (as a
reference to a &lt;code&gt;module&lt;/code&gt; object):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;my_package&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;my_package&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;my_subpackage&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;my_package.my_subpackage&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;baz&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Imports using &lt;code&gt;from&lt;/code&gt; can also be used to import particular attributes from
inside the namespaces of packages and modules.  For example, if the namespace
of module &lt;code&gt;foo&lt;/code&gt; contains a variable &lt;code&gt;foo_var&lt;/code&gt; then that variable can be
imported with this statement:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;my_package.foo&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;foo_var&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In fact, attributes inside package and module namespaces can &lt;em&gt;only&lt;/em&gt; be imported
using a &lt;code&gt;from&lt;/code&gt; import statement, never with a bare &lt;code&gt;import&lt;/code&gt; statement.  This is
discussed further in the next subsection.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="possible-confusions-in-import-syntax"&gt;
&lt;h3&gt;3.3. &lt;a class="toc-backref" href="#id7"&gt;Possible confusions in import syntax&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;One possibly-confusing aspect of Python imports is that the dot symbol is
overloaded in Python’s syntax.  In Python expressions the dot is used for
attribute access, such as in &lt;code&gt;my_class.my_attribute&lt;/code&gt;.  But in the dotted paths
of import statements the dot essentially means “subdirectory” and should be
thought of more as a “/” character in a pathname.  Import statements are an
exception in that they are the only statements where the dot syntax means
something other than attribute access.  In import statements the dot can &lt;em&gt;only&lt;/em&gt;
be part of a dotted path.&lt;/p&gt;
&lt;p&gt;Consider these valid import statements, assuming that &lt;code&gt;foo_var&lt;/code&gt; is a variable
assigned in module &lt;code&gt;foo.py&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;my_package&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="c1"&gt;# Works.&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;my_package.foo&lt;/span&gt; &lt;span class="c1"&gt;# Works.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;After the second import above the subexpression &lt;code&gt;my_package.foo&lt;/code&gt; is definitely
usable in Python expressions.  The subexpression &lt;code&gt;my_package.foo.foo_var&lt;/code&gt; is
too, because the initial module-scope attributes of &lt;code&gt;foo&lt;/code&gt; are created when it
is imported and initialized.  The name &lt;code&gt;foo_var&lt;/code&gt; is then an attribute of the
&lt;code&gt;module&lt;/code&gt; object for &lt;code&gt;foo&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The first import above is essentially the same as the second one except that
in the second one the &lt;code&gt;module&lt;/code&gt; object for &lt;code&gt;foo&lt;/code&gt; is imported under the name &lt;code&gt;foo&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Given the apparent pattern above the following may seem like it should work,
but it is not allowed:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;my_package.foo&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;foo_var&lt;/span&gt; &lt;span class="c1"&gt;# Works.&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;my_package.foo.foo_var&lt;/span&gt; &lt;span class="c1"&gt;# FAILS!&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;my_package.foo.foo_var&lt;/span&gt; &lt;span class="kn"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;fv&lt;/span&gt; &lt;span class="c1"&gt;# Also FAILS!&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The first import works because &lt;code&gt;from&lt;/code&gt; imports are allowed to import attributes
from the namespaces of packages and modules.  But the second import fails
because bare &lt;code&gt;import&lt;/code&gt; statements cannot be used to import attributes from the
namespaces of packages and modules.  Bare &lt;code&gt;import&lt;/code&gt; statements can only be
passed dotted paths, and dotted paths correspond to files and directories in
the filesystem, not to attributes inside modules.  Renaming doesn’t change
that, so the third import also fails.  This holds even when the expression
&lt;code&gt;my_package.foo.foo_var&lt;/code&gt; is usable in Python expressions.&lt;/p&gt;
&lt;p&gt;Another thing you cannot do is assign Python variables as aliases to dotted
paths.  So, while it seems like it would be convenient, this code does not work:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;my_package.foo&lt;/span&gt; &lt;span class="kn"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;mpf&lt;/span&gt; &lt;span class="c1"&gt;# Works.&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;mpf&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;foo_var&lt;/span&gt; &lt;span class="c1"&gt;# FAILS! Only dotted paths directly after from statements.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Although the attribute-access pattern of modules mimics the dotted-path
syntax, they are not the same thing.  The variable &lt;code&gt;mpf&lt;/code&gt; is a reference
to the &lt;code&gt;module&lt;/code&gt; object for &lt;code&gt;foo&lt;/code&gt;.  It cannot be substituted for a dotted path.&lt;/p&gt;
&lt;p&gt;Since references to module objects cannot be used in import statements, the full
dotted paths must always be entered.  Relative dotted paths, covered in the
next section, can simplify some cases of having to write out the full dotted paths.&lt;/p&gt;
&lt;p&gt;To avoid these possible confusions, remember that dotted paths in Python import
statements always refer to filesystem objects (either directories or &lt;code&gt;.py&lt;/code&gt;
files).  &lt;strong&gt;The first specifier in any import statement, whether a bare&lt;/strong&gt;
&lt;code&gt;import&lt;/code&gt; &lt;strong&gt;or a&lt;/strong&gt; &lt;code&gt;from&lt;/code&gt; &lt;strong&gt;import, can only be a dotted path&lt;/strong&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="relative-imports"&gt;
&lt;h2&gt;4. &lt;a class="toc-backref" href="#id8"&gt;Relative imports&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In the previous section we saw that dotted paths in absolute import statements
must always be typed out in full.  In the case of &lt;strong&gt;intra-package imports&lt;/strong&gt; —
imports from subpackages and modules inside the same package — relative
imports can often be used to simplify the dotted-path expressions.  Keep in
mind that relative imports are &lt;em&gt;only&lt;/em&gt; allowed for intra-package imports; all
other imports must be absolute imports.&lt;/p&gt;
&lt;p&gt;Relative imports are to absolute imports as relative filename paths are to
absolute filename paths.  They allow for shortened expressions relative to
another directory.  First we will extend the definition of dotted paths to
allow for relative dotted paths.&lt;/p&gt;
&lt;div class="section" id="relative-dotted-paths"&gt;
&lt;h3&gt;4.1. &lt;a class="toc-backref" href="#id9"&gt;Relative dotted paths&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;A &lt;strong&gt;relative dotted path&lt;/strong&gt; is similar to an absolute dotted path except that it
always starts with a dot symbol.  If you are familiar with relative paths in a
shell such as Bash the syntax is similar.&lt;/p&gt;
&lt;p&gt;Relative dotted paths have different meanings depending on the location of the
module in which they occur.  They are interpreted relative to the directory
containing the module in which they occur:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;A single dot refers to the directory containing the module.  It can occur
alone or at the beginning of a longer dotted path.  As examples, the
following correspondences hold inside the &lt;code&gt;foo&lt;/code&gt; module (located in directory
&lt;code&gt;my_package&lt;/code&gt;).  The first two components on a line are equivalent filesystem
paths relative to directory &lt;code&gt;src/my_package&lt;/code&gt;, and the final one is the Python
dotted path.  (Note in the second line that while &lt;code&gt;bar&lt;/code&gt; without the dot would
be an equivalent relative pathname in a shell, as a relative dotted path the
leading dot is required.)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="math"&gt;
\begin{align*}
\scriptstyle\texttt{my_package} \;\Longleftrightarrow\;\; \texttt{.} \;\;\Longrightarrow\; \texttt{.} \\
\end{align*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{align*}
\scriptstyle\texttt{my_package/bar.py} \;\Longleftrightarrow\; \texttt{./bar.py} \;\Longrightarrow\; \texttt{.bar} \\
\end{align*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{align*}
\scriptstyle\texttt{my_package/my_subpackage/baz.py} \;\Longleftrightarrow\; \texttt{./my_subpackage/baz.py} \;\Longrightarrow\; \texttt{.my_subpackage.baz} \\
\end{align*}
&lt;/div&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Two dots refer to the parent directory of the directory containing the
module.  The two dots can occur alone or at the beginning of a longer dotted
path.  The following correspondences hold inside the &lt;code&gt;baz&lt;/code&gt; module (which is
located in directory &lt;code&gt;my_subpackage&lt;/code&gt;).  The first two components on a line are
equivalent filesystem paths relative to directory
&lt;code&gt;src/my_package/my_subpackage&lt;/code&gt; and the final one is the Python dotted path:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="math"&gt;
\begin{align*}
\scriptstyle\texttt{my_package} \;\Longleftrightarrow\;\; \texttt{..} \;\;\Longrightarrow\; \texttt{..} \\
\end{align*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
\scriptstyle\texttt{my_package/bar.py} \;\Longleftrightarrow\; \texttt{my_package/my_subpackage/../bar.py} \;\Longrightarrow\; \texttt{..bar}
\end{equation*}
&lt;/div&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Each additional dot goes up one more directory level.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Suppose there were another subpackage named &lt;code&gt;sibling&lt;/code&gt; at the same level as
&lt;code&gt;my_subpackage&lt;/code&gt;.  Then a module &lt;code&gt;cousin&lt;/code&gt; in it could be imported from &lt;code&gt;baz&lt;/code&gt; by
going up and then down as follows:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\scriptstyle\texttt{my_package/sibling/cousin} \;\Longrightarrow\; \texttt{..sibling.cousin}
\end{equation*}
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h3&gt;4.2. &lt;a class="toc-backref" href="#id10"&gt;Relative imports&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Now that relative dotted paths have been covered, relative imports are
straightforward: just use a relative dotted path instead of an absolute dotted
path (but remember that they are only allowed for intra-package imports).&lt;/p&gt;
&lt;p&gt;There is another important restriction on relative imports: &lt;strong&gt;A relative dotted
path can only appear after a&lt;/strong&gt; &lt;code&gt;from&lt;/code&gt; &lt;strong&gt;statement.&lt;/strong&gt;  It might seem like you
should be able to write imports such as &lt;code&gt;import .bar&lt;/code&gt; from the &lt;code&gt;foo&lt;/code&gt; module and
&lt;code&gt;import ..bar&lt;/code&gt; from &lt;code&gt;baz&lt;/code&gt; module, but those are syntax errors.  The reason this
is not allowed is that the relative dotted paths (such as &lt;code&gt;.bar&lt;/code&gt;) after the bare
&lt;code&gt;import&lt;/code&gt; statements are not valid Python names and therefore cannot be used in
Python expressions.&lt;/p&gt;
&lt;p&gt;The following are all valid relative imports from the &lt;code&gt;foo&lt;/code&gt; module:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;.&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;.bar&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;bar_var&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;.&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;my_subpackage&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;.my_subpackage&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;baz&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;.my_subpackage.baz&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;baz_var&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;These relative imports are all valid in the &lt;code&gt;baz&lt;/code&gt; module:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;..&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;..bar&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;bar_var&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In addition to importing modules and subpackages, &lt;code&gt;from&lt;/code&gt; imports using only-dot
paths such as &lt;code&gt;.&lt;/code&gt; and &lt;code&gt;..&lt;/code&gt; can also be used to import attributes from package
and subpackage namespaces (i.e., from &lt;code&gt;__init__.py&lt;/code&gt; namespaces)  For example,
this import in module &lt;code&gt;foo&lt;/code&gt; would import the variable &lt;code&gt;init_var&lt;/code&gt; defined in
module &lt;code&gt;my_package.__init__.py&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;.&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;init_var&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="imports-in-scripts"&gt;
&lt;span id="section5"&gt;&lt;/span&gt;&lt;h2&gt;5. &lt;a class="toc-backref" href="#id11"&gt;Imports in scripts&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;A &lt;strong&gt;script&lt;/strong&gt; is any Python module which is directly run by the Python
interpreter.  This can be done from the command line with the &lt;code&gt;python&lt;/code&gt; command,
by clicking an icon, or via some other invocation method such as from a menu.
Python applications are usually started by running a Python module
as a script.&lt;/p&gt;
&lt;p&gt;Scripts have a few unique properties not shared by other modules:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;The directory containing the script file is automatically inserted to
&lt;code&gt;sys.path[0]&lt;/code&gt; when the script is run by the Python interpreter.   The
absolute directory path is always added; the current working directory, in
the shell or in Python, has no effect on this.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;__name__&lt;/code&gt; attribute of the script’s module is always set to
&lt;code&gt;"__main__"&lt;/code&gt; when it is run as a script, regardless of the file’s name.&lt;/li&gt;
&lt;li&gt;By default a script is not run as part of a package, even if there happens
to be an &lt;code&gt;__init__.py&lt;/code&gt; in its directory.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Property 1 allows a script to import any package or module which is located in
its directory as an absolute, non-dotted import.  This is helpful if the
directory contains top-level packages or standalone modules that are intended
to be imported.  In some situations this can cause problems such as unintended
imports due to name shadowing or modules inside packages being imported as if
they were standalone modules.&lt;/p&gt;
&lt;p&gt;Property 2 is what allows the use of this common idiom in Python scripts:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"__main__"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;# A commonly-seen example, running function `main`.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Code in that conditional block only executes when the module is directly run as
a script and not when the module is imported from another Python module (some
modules are meant to be used both ways).&lt;/p&gt;
&lt;div class="section" id="scripts-outside-of-packages"&gt;
&lt;h3&gt;5.1. &lt;a class="toc-backref" href="#id12"&gt;Scripts outside of packages&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The standard idiom for Python scripts is that they should be located outside of
packages.  The script can then load any packages or modules it needs.  There
are some use cases for scripts inside packages, which will be covered in the
subsection following this one.&lt;/p&gt;
&lt;p&gt;The rule for imports in scripts located outside packages is simple: scripts
outside packages can only use absolute imports.  Any absolute imports are
allowed, but of course modules inside packages should almost always be imported
as part of their package, using the dotted-path syntax relative to their
package root.  In some cases it may be necessary to insert paths to
&lt;code&gt;sys.path[1]&lt;/code&gt; (after the current directory at &lt;code&gt;sys.path[0]&lt;/code&gt;) in order for
Python to discover the necessary modules and packages to import.&lt;/p&gt;
&lt;p&gt;If you use a &lt;code&gt;setup.py&lt;/code&gt; for your project then scripts outside packages &lt;a class="reference external" href="https://python-packaging.readthedocs.io/en/latest/command-line-scripts.html"&gt;can be
added to a project&lt;/a&gt;
by using the &lt;code&gt;scripts&lt;/code&gt; keyword argument.  For development this would involve
setting up the project with a &lt;code&gt;setup.py&lt;/code&gt; and then installing the project in
editable mode, such as by running &lt;code&gt;pip install -e .&lt;/code&gt; in the directory with
&lt;code&gt;setup.py&lt;/code&gt;.  (The &lt;code&gt;setup.py&lt;/code&gt; file is usually placed in the project’s root
directory, which is &lt;code&gt;my_project&lt;/code&gt; in the project skeleton given earlier).  This
provides a shell command, in the shell’s search path, to run the script.  To
add or remove scripts from the project the &lt;code&gt;setup.py&lt;/code&gt; would have to be modified
and the package reinstalled.  A similar thing can be done using the more-recent
&lt;code&gt;pyproject.toml&lt;/code&gt; files if you use that method to set up projects rather than
using a &lt;code&gt;setup.py&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="scripts-inside-packages"&gt;
&lt;h3&gt;5.2. &lt;a class="toc-backref" href="#id13"&gt;Scripts inside packages&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Scripts can also be run inside packages, but the special properties of scripts
listed above have some side-effects which need to be taken into account.&lt;/p&gt;
&lt;p&gt;Property 3 means that the package the script is inside of is not automatically
imported when the script runs.  To import modules from the package the script
will by default use non-dotted absolute imports (based on Property 1, that the
directory is added to &lt;code&gt;sys.path&lt;/code&gt;).  This only works correctly in simple cases
where the imported modules are essentially standalone modules themselves.  Even
if the script itself imports the full package in the usual way, the running
script is still not correctly set up as a module of the package.&lt;/p&gt;
&lt;p&gt;If the script does explicitly import its containing package then dotted
absolute imports from the package will work.  But the script module itself
should never be imported by any other module in the package since it is cached
as the &lt;code&gt;__main__&lt;/code&gt; module by Property 2 and a double import will result.&lt;/p&gt;
&lt;p&gt;To get around these problems and correctly run scripts inside packages what is
needed is a way to automatically import the containing package and then run the
script as a part of the package.  There are several possible ways to do this:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Invoke the script using &lt;code&gt;python -m &amp;lt;fullyQualifiedName&amp;gt;&lt;/code&gt;, where
&lt;code&gt;&amp;lt;fullyQualifiedName&amp;gt;&lt;/code&gt; is the fully-qualified name of the module inside the
package (i.e., its absolute dotted path).  Note that the directory
containing the top-level package directory must be in &lt;code&gt;sys.path&lt;/code&gt; or the
command will fail.  You could write a shell script wrapper for the &lt;code&gt;python&lt;/code&gt;
command to calculate a &lt;code&gt;PYTHONPATH&lt;/code&gt; and qualified name and then invoke
&lt;code&gt;python -m&lt;/code&gt;.  Generally, though, the invocation method differs from that of
other Python scripts.&lt;/li&gt;
&lt;li&gt;Set the &lt;code&gt;__package__&lt;/code&gt; attribute of the script, in the script, to the
fully-qualified name and then import the package in the correct way.  This
is more complex than you might expect, but fortunately there is a &lt;a class="reference external" href="https://abarker.github.io/set-package-attribute/"&gt;package
on PyPI&lt;/a&gt; which can do
this for you automatically (and optionally also remove the directory’s
&lt;code&gt;sys.path&lt;/code&gt; entry).&lt;/li&gt;
&lt;li&gt;Create a &lt;code&gt;setup.py&lt;/code&gt; file and &lt;a class="reference external" href="http://www.python.org/"&gt;create an entry point&lt;/a&gt; for the script via the &lt;code&gt;console_scripts&lt;/code&gt; keyword.
This is similar to the &lt;code&gt;scripts&lt;/code&gt; keyword described above, but it allows
modules inside packages to be run via an entry-point function.  To add or
remove entry points the &lt;code&gt;setup.py&lt;/code&gt; file would have to be modified and the
package reinstalled.  This creates commands which are directly executable in
the shell, under the command name specified in &lt;code&gt;setup.py&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="not-covered"&gt;
&lt;h2&gt;6. &lt;a class="toc-backref" href="#id14"&gt;Not covered&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;This article has covered the basics of the Python import system, but some
important topics have not been discussed.  They tend to occur or be used in
special or advanced cases.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Star imports&lt;/strong&gt;: By default, the statement &lt;code&gt;from my_module import *&lt;/code&gt; imports
all the names in the &lt;code&gt;my_module&lt;/code&gt; namespace which do not start with the
underscore character.  If &lt;code&gt;__all__&lt;/code&gt; is defined in &lt;code&gt;my_module&lt;/code&gt; as a list of
string variable names then &lt;code&gt;*&lt;/code&gt;-imports from the module will only import those
names.  Anything else would need to be explicitly imported.  The &lt;code&gt;__all__&lt;/code&gt; list
for an &lt;code&gt;__init__.py&lt;/code&gt; file can also contain the names of modules and subpackages
to import: a &lt;code&gt;*&lt;/code&gt;-import of the corresponding package or subpackage will then
implicitly perform the imports (which would need to be done explicitly in an
ordinary module).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Circular imports&lt;/strong&gt;:  This problem can arise when one module imports another
module which then imports the first module again.  The usual solution is to
reorganize the module structure or to put the problematic import inside a
function so it is not performed on module initialization.  Circular imports are
discussed in the answer to this Python &lt;span class="caps"&gt;FAQ&lt;/span&gt; question: “&lt;a class="reference external" href="https://docs.python.org/3/faq/programming.html#what-are-the-best-practices-for-using-import-in-a-module"&gt;What are the ‘best
practices’ for using import in a module?&lt;/a&gt;”&lt;/p&gt;
&lt;p id="namespace-packages"&gt;&lt;strong&gt;Namespace packages&lt;/strong&gt;: Namespace packages allow one or more toplevel
directories having the same directory name, but without &lt;code&gt;__init__.py&lt;/code&gt; files, to
function like a common namespace for all the modules and packages in all of
those directories which are discoverable on &lt;code&gt;sys.path&lt;/code&gt;.  This can be useful for
large distributions, but there are also drawbacks such as the lack of
&lt;code&gt;__init__.py&lt;/code&gt; files.  Most people should continue to use &lt;code&gt;__init__.py&lt;/code&gt; files
and create packages with a single top-level directory.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dynamic import calls&lt;/strong&gt;:  Suppose you want do perform an import but you do
not know the name of the module to import until runtime.  The functional
interface to the import command is called &lt;code&gt;__import__&lt;/code&gt;.  It can take a string
argument, e.g., &lt;code&gt;module_found_at_runtime =
__import__(runtime_calculated_name)&lt;/code&gt;, where &lt;code&gt;runtime_calculated_name&lt;/code&gt; is a string.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;pth files&lt;/strong&gt;: Pth files are special files which contain the pathnames of
packages or modules to import.  Using pth files only works when they are placed
in the special system &lt;code&gt;site-packages&lt;/code&gt; directory.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Importing from zip files&lt;/strong&gt;: Python allows modules to be imported from
zipfiles, provided the &lt;code&gt;.zip&lt;/code&gt; archive file is located on &lt;code&gt;sys.path&lt;/code&gt;.   The
directory structure in the zip file then acts as a regular directory.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lower-level APIs of the import system&lt;/strong&gt;:  The &lt;a class="reference external" href="https://docs.python.org/3/reference/import.html"&gt;full Python import system&lt;/a&gt; is complicated and
customizable.  There are protocols to allow it to be dynamically modified in
various ways for special applications.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="further-reading"&gt;
&lt;h2&gt;7. &lt;a class="toc-backref" href="#id15"&gt;Further reading&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;The official Python documentation on &lt;a class="reference external" href="https://docs.python.org/3/reference/import.html"&gt;imports&lt;/a&gt; and
&lt;a class="reference external" href="https://docs.python.org/3.7/tutorial/modules.html"&gt;modules&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;A detailed &lt;a class="reference external" href="https://chrisyeh96.github.io/2017/08/08/definitive-guide-python-imports.html"&gt;guide to Python imports&lt;/a&gt; by Chris Yeh.&lt;/li&gt;
&lt;li&gt;An &lt;a class="reference external" href="https://realpython.com/absolute-vs-relative-python-imports"&gt;introduction to absolute vs. relative imports&lt;/a&gt;, including a discussion
of formatting style.   By Mbithe Nzomo.&lt;/li&gt;
&lt;li&gt;A discussion of some of the often subtle &lt;a class="reference external" href="http://python-notes.curiousefficiency.org/en/latest/python_concepts/import_traps.html"&gt;import traps&lt;/a&gt;
which can arise, by Nick Coghlan.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (true) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js','color.js','AMSmath.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'black ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="programming"></category><category term="python"></category></entry></feed>