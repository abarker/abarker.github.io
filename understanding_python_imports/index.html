<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="author" content="Allen Barker" />

        <meta name="description" content="Description of modern Python imports.
" />
        <meta property="og:type" content="article" />
        <meta name="twitter:card" content="summary">

<meta name="keywords" content="programming, python, programming, " />

<meta property="og:title" content="Understanding Python Imports "/>
<meta property="og:url" content="https://abarker.github.io/understanding_python_imports/" />
<meta property="og:description" content="Description of modern Python imports." />
<meta property="og:site_name" content="abarker.github.io" />
<meta property="og:article:author" content="Allen Barker" />
<meta property="og:article:published_time" content="2019-07-12T14:13:00-04:00" />
<meta property="og:article:modified_time" content="2019-07-12T14:13:00-04:00" />
<meta name="twitter:title" content="Understanding Python Imports ">
<meta name="twitter:description" content="Description of modern Python imports.">

        <title>Understanding Python Imports  · abarker.github.io
</title>
        <link href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-combined.min.css" rel="stylesheet">
        <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.1/css/font-awesome.css" rel="stylesheet">
<link rel="stylesheet" href="https://abarker.github.io/theme/css/style.min.css?3c291e15">
        <link rel="shortcut icon" href="https://abarker.github.io/theme/images/favicon.ico" type="image/x-icon" />
        <link rel="icon" href="https://abarker.github.io/theme/images/apple-touch-icon-152x152.png" type="image/png" />
        <link rel="apple-touch-icon" href="https://abarker.github.io/theme/images/apple-touch-icon.png"  type="image/png" />
        <link rel="apple-touch-icon" sizes="57x57" href="https://abarker.github.io/theme/images/apple-touch-icon-57x57.png" type="image/png" />
        <link rel="apple-touch-icon" sizes="72x72" href="https://abarker.github.io/theme/images/apple-touch-icon-72x72.png" type="image/png" />
        <link rel="apple-touch-icon" sizes="76x76" href="https://abarker.github.io/theme/images/apple-touch-icon-76x76.png" type="image/png" />
        <link rel="apple-touch-icon" sizes="114x114" href="https://abarker.github.io/theme/images/apple-touch-icon-114x114.png" type="image/png" />
        <link rel="apple-touch-icon" sizes="120x120" href="https://abarker.github.io/theme/images/apple-touch-icon-120x120.png" type="image/png" />
        <link rel="apple-touch-icon" sizes="144x144" href="https://abarker.github.io/theme/images/apple-touch-icon-144x144.png" type="image/png" />
        <link rel="apple-touch-icon" sizes="152x152" href="https://abarker.github.io/theme/images/apple-touch-icon-152x152.png" type="image/png" />
        <link href="https://abarker.github.io/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="abarker.github.io - Full Atom Feed" />



    </head>
    <body>
        <div id="content-sans-footer">
        <div class="navbar navbar-static-top">
            <div class="navbar-inner">
                <div class="container-fluid">
                    <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </a>
                    <a class="brand" href="https://abarker.github.io/"><span class=site-name>abarker.github.io</span></a>
                    <div class="nav-collapse collapse">
                        <ul class="nav pull-right top-menu">
                            <li ><a href="https://abarker.github.io">Home</a></li>
                            <li ><a href="https://abarker.github.io/categories">Categories</a></li>
                            <li ><a href="https://abarker.github.io/tags">Tags</a></li>
                            <li ><a href="https://abarker.github.io/archives">Archives</a></li>
                            <li><form class="navbar-search" action="https://abarker.github.io/search.html" onsubmit="return validateForm(this.elements['q'].value);"> <input type="text" class="search-query" placeholder="Search" name="q" id="tipue_search_input"></form></li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        <div class="container-fluid">
            <div class="row-fluid">
                <div class="span1"></div>
                <div class="span10">
<article itemscope>
<div class="row-fluid">
    <header class="page-header span10 offset2">
    <h1><a href="https://abarker.github.io/understanding_python_imports/"> Understanding Python&nbsp;Imports  </a></h1>
    </header>
</div>

<div class="row-fluid">
    <div class="span2 table-of-content">
        <nav>
        <h4>Contents</h4>
        <div class="toc" id="">

<ul class="simple">
<li><a class="reference internal" href="#review-of-python-modules-and-packages" id="id2">Review of Python modules and packages</a></li>
<li><a class="reference internal" href="#the-python-path-search-list-sys-path" id="id3">The Python path-search list: <code>sys.path</code></a></li>
<li><a class="reference internal" href="#absolute-imports" id="id4">Absolute imports</a><ul>
<li><a class="reference internal" href="#absolute-dotted-paths-and-the-filesystem" id="id5">Absolute dotted paths and the filesystem</a></li>
<li><a class="reference internal" href="#absolute-imports-of-subpackages-and-modules-in-packages" id="id6">Absolute imports of subpackages and modules in packages</a></li>
<li><a class="reference internal" href="#possible-confusions-in-import-syntax" id="id7">Possible confusions in import syntax</a></li>
</ul>
</li>
<li><a class="reference internal" href="#relative-imports" id="id8">Relative imports</a><ul>
<li><a class="reference internal" href="#relative-dotted-paths" id="id9">Relative dotted paths</a></li>
<li><a class="reference internal" href="#id1" id="id10">Relative imports</a></li>
</ul>
</li>
<li><a class="reference internal" href="#imports-in-scripts" id="id11">Imports in scripts</a><ul>
<li><a class="reference internal" href="#scripts-outside-of-packages" id="id12">Scripts outside of packages</a></li>
<li><a class="reference internal" href="#scripts-inside-packages" id="id13">Scripts inside packages</a></li>
</ul>
</li>
<li><a class="reference internal" href="#not-covered" id="id14">Not covered</a></li>
<li><a class="reference internal" href="#further-reading" id="id15">Further reading</a></li>
</ul>
</div>
        </nav>
    </div>
    <div class="span8 article-content">

            
            
<p>Python has many strong points and tends to have a learning curve that is
friendly to beginners.  The import system, however, is one part of the
language which can be confusing.  There are a few possible sources of confusion:</p>
<ul class="simple">
<li>Certain import statements which work for modules inside packages do not work
for modules outside of packages, and vice versa.</li>
<li>Some of the import syntax does not generalize in the way one might first
expect it does.</li>
<li>Modules run as scripts have some special properties which can affect imports.</li>
<li>Lack of familiarity with the Python package mechanism in general.</li>
<li>Old documentation can come up in searches.  (For example, Python 2 had
something called implicit relative import which Python 3 does not have.  If
you’re still using Python 2, disable implicit relative imports by using <code>from
__future__ import absolute_import</code> as the first import.)</li>
</ul>
<p>This article only discusses modern Python imports (Python versions &gt;3.0).
Basic familiarity with the concepts of files and directories/folders is
assumed.  Before imports are discussed Python modules and packages will be
briefly reviewed.</p>
<div class="section" id="review-of-python-modules-and-packages">
<h2>1. <a class="toc-backref" href="#id2">Review of Python modules and packages</a></h2>
<p>At some point most non-trivial projects become large enough that it makes sense
to separate the code into separate files.  In Python those separate files are
called <strong>modules</strong>.  The use of modules can make the codebase easier to
understand and, as the name implies, more modular.  Imports are used to allow
code in one module to access and use code from other modules.</p>
<p>The Python module and package system is closely tied to the directories and
files in the underlying filesystem.  Understanding the correspondence is
important in understanding the Python import system.  The basic correspondence
can be summarized as follows:</p>
<div class="math">
\begin{align*}
\textrm{files with}\; \texttt{.py}\; \textrm{extension} \;\Longrightarrow\; \textrm{python modules} \\
\end{align*}
</div>
<div class="math">
\begin{align*}
\substack{\textrm{directory subtrees where each} \\
\textrm{directory has an}\; \texttt{__init__.py}\; \textrm{file}} \;\Longrightarrow\; \textrm{python packages} \\
\end{align*}
</div>
<p>A file containing Python code is always a module and vice versa.  Such files
usually have names ending with the <code>.py</code> extension.  All Python programs are
composed of one or more modules.  <strong>Packages</strong> are collections of modules
organized in a certain way:</p>
<ul class="simple">
<li>Any Python module which is inside a directory containing an <code>__init__.py</code>
file (which may or may not be an empty file) is by definition part of the
package associated with that <code>__init__.py</code> file.  The name of the package is
the same as the name of the directory.  (Formally, packages are just a
special kind of module, but in this context packages and modules will be
considered to be distinct.)</li>
<li><strong>Subpackages</strong> are defined similarly to packages, as subdirectories of a
package directory which also contain an <code>__init__.py</code> file.  Subpackages can
have their own subpackages, and so forth.</li>
<li>A module with no <code>__init__.py</code> in its directory is not part of any package or
subpackage (excepting namespace packages, an advanced topic briefly discussed
<a class="reference internal" href="#namespace-packages">later</a>).</li>
</ul>
<p>Consider this example directory structure, which will be used throughout the article:</p>
<pre class="literal-block">
my_project
│
├── bin
│   └── my_script.py
│
└── src
    ├── my_standalone_module.py
    │
    └── my_package
        ├── __init__.py
        ├── foo.py
        ├── bar.py
        │
        └── my_subpackage
            ├── __init__.py
            └── baz.py
</pre>
<p>This is the skeleton of a project called <code>my_project</code> which contains one script
called <code>my_script</code> in its <code>bin</code> directory and a package called <code>my_package</code> in
its <code>src</code> directory.  (Some people prefer not to have a separate <code>src</code>
directory, but there are some <a class="reference external" href="https://hynek.me/articles/testing-packaging/">good</a> <a class="reference external" href="https://blog.ionelmc.ro/2014/05/25/python-packaging/">reasons</a> to include it.)  There
is also a module named <code>my_standalone_module</code> in the <code>src</code> directory.</p>
<p>The <code>__init__.py</code> files in the directories are essentially the modules for the
corresponding packages or subpackages.  When a module is imported its code
is run to initialize it.  When a package or subpackage is
imported its <code>__init__.py</code> is implicitly imported and run.  It is easy to
underestimate <code>__init__.py</code> files, since they are often empty files, but they
are quite important as far as how Python packages work.</p>
<p>A package’s namespace is by definition the namespace of the <code>__init__.py</code>
module in its directory.  This includes any names which are explicitly imported
into the <code>__init__.py</code> file.  Whenever a subpackage is imported its name is
automatically added to the namespace of <code>__init__.py</code> (and hence to the package
namespace).  The top-level namespace of a package constitutes its main
application-programmer interface (<span class="caps">API</span>).  Names which should be exposed by that
<span class="caps">API</span> must be imported into the <code>__init__.py</code> file.</p>
<p>Subpackages are imported (and their <code>__init__.py</code> files are run) when they are
either 1) explicitly imported or 2) automatically imported just before a module
or subpackage contained within that subpackage is imported.  As noted above,
the <code>module</code> object representing the subpackage is also added to the namespace
of the package or subpackage that imports it (under its subpackage name).</p>
<p>Python <code>import</code> statements always contain a specifier for a package or module
to import.  Equivalently, they always contain a specifier for the corresponding
file or a directory in the filesystem.  While Python’s import statements never
use the <code>.py</code> file extension for naming modules, other than that the names of
modules, packages, and subpackages correspond directly with filesystem objects
(files and directories) and their filesystem names.</p>
</div>
<div class="section" id="the-python-path-search-list-sys-path">
<h2>2. <a class="toc-backref" href="#id3">The Python path-search list: <code>sys.path</code></a></h2>
<p>The <code>sys.path</code> list is the root of all imports in Python (excepting system
library modules such as <code>math</code>, which are always found in their usual
location).  This list tells the Python import system where to look for packages
and modules to import.  It is just a list containing directory pathnames,
represented as strings.</p>
<p>Understanding <code>sys.path</code> is important in understanding Python imports.  <strong>If
the pathname of the directory containing a module’s file or else containing the
package directory is not on the</strong> <code>sys.path</code> <strong>list then Python will not be
able to import the respective module or package.</strong>  Note that when external
packages are installed with <code>pip</code> or similar programs they are placed in the
system <tt class="docutils literal"><span class="pre">site-packages</span></tt> directory, which is on <code>sys.path</code> by default.</p>
<p>Ordering in the <code>sys.path</code> list is important: The first match found in the list
is the one that is used.  The paths themselves are strings which can represent
relative or absolute pathnames for the underlying operating system.  Any
relative pathnames in <code>sys.path</code> (such as <code>".."</code>) are interpreted relative to
Python’s current working directory (<span class="caps">CWD</span>).  The <span class="caps">CWD</span> is initially set to the
command shell’s notion of current directory (i.e., the directory you are in
when you invoke the <code>python</code> command), but it can be changed by calls to
<code>os.setcwd()</code>.</p>
<p>Directories can be added to the initial <code>sys.path</code> list from command shells
like Bash by setting the <code>PYTHONPATH</code> environment variable before invoking the
<code>python</code> command.  The <code>PYTHONPATH</code> environment variable should contain a
colon-separated string of the pathnames to be added.  While this has its uses,
it is usually not the recommended way to initialize <code>sys.path</code>.</p>
<p>Actually importing a package which is located in a directory on the <code>sys.path</code>
list is simple: just import the package directory name.  Similarly, to import a
non-package module located in a directory on <code>sys.path</code> just import the
module’s file name leaving off the <code>.py</code> extension.  For example, suppose the path
to directory <code>my_project/src</code> is in the <code>sys.path</code> list.  Then the following
imports work for the project skeleton given above:</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">my_package</span>
<span class="kn">import</span> <span class="nn">my_standalone_module</span>
</pre></div>
<p>These statements import the package <code>my_package</code> in the directory of that same
name and then import the module <code>my_standalone_module</code> with code located in the
file <code>my_standalone_module.py</code>.  The same imports can be done with a single
statement, though that style is not generally recommended:</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">my_package</span><span class="o">,</span> <span class="nn">my_standalone_module</span> <span class="c1"># Same as above two imports.</span>
</pre></div>
<p>What is actually being imported here are two <code>module</code> objects, one representing
the package <code>my_package</code> and the other representing the module <code>my_module</code>.
For example, if you run <code>str(type(my_package))</code> the result is <code>"&lt;class
'module'&gt;"</code>.</p>
<p>All the names in the namespace of a package or module represented by a <code>module</code>
object are also attributes of that <code>module</code> object (i.e., they are in its
<code>__dict__</code>).  This is what allows those attributes to be accessed directly from
the imported module objects.  For example, assuming the <code>__init__.py</code> of
<code>my_package</code> defines the variable <code>init_var</code> and <code>my_standalone_module</code> defines
<code>my_standalone_module_var</code> expressions like <code>my_package.init_var</code> and
<code>my_standalone_module.my_standalone_module_var</code> can be used in any module that
makes the above imports.</p>
<p>The <code>as</code> keyword can also be used to rename an import under an alias:</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">my_package</span> <span class="kn">as</span> <span class="nn">mp</span>
<span class="kn">import</span> <span class="nn">my_standalone_module</span> <span class="kn">as</span> <span class="nn">msm</span>
<span class="kn">import</span> <span class="nn">my_package</span> <span class="kn">as</span> <span class="nn">mp</span><span class="o">,</span> <span class="nn">my_standalone_module</span> <span class="kn">as</span> <span class="nn">msm</span> <span class="c1"># Same as above two.</span>
</pre></div>
<p>The <code>as</code> keyword can be used anywhere in an import statement where a name in
the local namespace is being assigned a value.  It simply renames the variable
under which that package or module is imported.</p>
<p>Python always keeps a cache of imported packages and modules as <code>module</code>
objects, in the <code>sys.modules</code> dict, keyed by the fully-qualified name of the
package or module.  When an import statement is executed Python first looks in
that dict to see if the package or module has previously been imported.  If so
then it returns the previously-imported object.  Otherwise it tries to import
from the filesystem.  Re-importing a module requires the explicit use of the
builtin <code>reload</code> function.</p>
<p>The <code>from</code> statement can be used to import subpackages as well as particular
attributes defined in a package or module:</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">my_package</span> <span class="kn">import</span> <span class="n">init_var</span> <span class="k">as</span> <span class="n">iv</span><span class="p">,</span> <span class="n">my_subpackage</span> <span class="k">as</span> <span class="n">msp</span>
<span class="kn">from</span> <span class="nn">my_standalone_module</span> <span class="kn">import</span> <span class="n">my_standalone_module_var</span>
</pre></div>
<p>The first of these statements imports the attribute <code>init_var</code> from the
package namespace of <code>my_package</code>, renaming it as <code>iv</code>.  It also imports the
subpackage <code>my_subpackage</code>, renamed to <code>msp</code>.  The second statement imports the
attribute <code>my_standalone_module_var</code> from <code>my_standalone_module</code>.</p>
<p>Imports using the <code>from</code> keyword will be referred to as <code>from</code> imports, and
imports without the <code>from</code> keyword will be referred to as bare <code>import</code>
statements.</p>
</div>
<div class="section" id="absolute-imports">
<h2>3. <a class="toc-backref" href="#id4">Absolute imports</a></h2>
<p>We have already seen one kind of absolute import, which is the import of a
module or package from a directory on the <code>sys.path</code> list.  There is one more
kind of absolute import which has not yet been covered.  These are used to
import modules and subpackages which are located inside packages.  That kind of
import cannot be done correctly simply by placing the directory on <code>sys.path</code>
and then importing the module or subpackage.  (In fact, a package directory or
subdirectory, i.e., a directory with an <code>__init__.py</code> file, should <em>never</em>
appear in the <code>sys.path</code> list.  Doing that can introduce subtle bugs which can
be difficult to find.  Only the <em>parent</em> directory of the package should ever
appear in <code>sys.path</code>.)</p>
<p>Absolute imports <em>require</em> that the directory containing either the top-level
package directory or the non-package module being imported be discoverable on
the <code>sys.path</code> list.  Absolute imports can always be used, in any Python
module, regardless of whether it is inside a package or outside of a package.</p>
<p>Absolute imports for modules inside packages use a dotted-path syntax, e.g.,</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">my_package.foo</span>
</pre></div>
<p>This statement would import the module <code>foo</code> located in the <code>foo.py</code> file under
the name <code>my_package.foo</code> (an <code>as</code> keyword could be used to create an alias if
desired).  The next subsection covers the relation of these dotted paths to the
filesystem objects.  Once these dotted paths are understood absolute imports
will be much easier to discuss.</p>
<div class="section" id="absolute-dotted-paths-and-the-filesystem">
<h3>3.1. <a class="toc-backref" href="#id5">Absolute dotted paths and the filesystem</a></h3>
<p>For any package which can be discovered by looking in the directories on the
<code>sys.path</code> list there is corresponding <strong>dotted path</strong> to specify modules
(files) and subpackages (subdirectories) located inside the package (inside the
package’s directory subtree).  The slashes in operating-system pathnames are
essentially replaced with dots.  These dotted paths are always relative to the
package’s top-level directory (i.e., the highest-level directory containing an
<code>__init__.py</code> file),</p>
<p>Here are some examples of the correspondence, based on the project skeleton
above.  The filesystem pathnames are given on the left (assuming forward
slashes), and the corresponding dotted paths are on the right:</p>
<div class="math">
\begin{align*}
\scriptstyle\texttt{src/my_package} \;\Longrightarrow\; \texttt{mypackage} \\
\end{align*}
</div>
<div class="math">
\begin{align*}
\scriptstyle\texttt{src/my_package/foo.py} \;\Longrightarrow\; \texttt{mypackage.foo} \\
\end{align*}
</div>
<div class="math">
\begin{align*}
\scriptstyle\texttt{src/my_package/my_subpackage} \;\Longrightarrow\; \texttt{mypackage.my_subpackage} \\
\end{align*}
</div>
<div class="math">
\begin{equation*}
\scriptstyle\texttt{src/my_package/my_subpackage/baz.py} \;\Longrightarrow\; \texttt{mypackage.my_subpackage.baz}
\end{equation*}
</div>
<p>Note that the <code>.py</code> extension is omitted, but other than that the
correspondence is fairly simple.  In an import statement these dotted paths
<em>always</em> refer to objects on the filesystem.</p>
</div>
<div class="section" id="absolute-imports-of-subpackages-and-modules-in-packages">
<h3>3.2. <a class="toc-backref" href="#id6">Absolute imports of subpackages and modules in packages</a></h3>
<p>Now that dotted paths have been covered the discussion of importing modules
that are inside packages is fairly simple: just put the dotted path after the
import statement.  The first component of the dotted path is <em>always</em> the
top-level package name (i.e., the name of the directory which is the root of
the package subtree).  For package <code>my_package</code> as given above these are
all valid imports using <code>import</code> directly:</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">my_package</span>
<span class="kn">import</span> <span class="nn">my_package.foo</span>
<span class="kn">import</span> <span class="nn">my_package.my_subpackage</span>
<span class="kn">import</span> <span class="nn">my_package.my_subpackage</span> <span class="kn">as</span> <span class="nn">msp</span>
<span class="kn">import</span> <span class="nn">my_package.my_subpackage.baz</span>
</pre></div>
<p>All these imports result in a <code>module</code> object in the namespace which, when used
in an expression, syntactically matches the dotted path (except that the dots
are attribute accesses on <code>module</code> objects).  For example, the last import does
not actually add anything to the namespace of the module doing the import.
Instead, it adds the module attribute <code>baz</code> to the <code>my_subspace</code> namespace.
(At that point the <code>my_package</code> object is already in the namespace, and it
already has the attribute <code>my_subpackage</code>.)</p>
<p>This is a general property of bare <code>import</code> statements: After a bare <code>import</code>
the dotted-path used to make the import is always usable in Python expressions
in the importing module.  But in those expressions the dot symbol represents
attribute access, unlike in the import statement itself.  This will be
discussed further in the next subsection.</p>
<p>Python uses its <code>sys.modules</code> cache for dotted-path imports, too.  It goes down
the names on the dotted path and if it finds one that has not previously been
imported then it imports the remainder of the dotted path from the filesystem.
Any previously-imported packages or modules are taken from the cache.</p>
<p>Imports using <code>from</code> also work for dotted paths.  The imports below are all
valid imports for package <code>my_package</code>.  They correspond to the imports above
(except for the first one, which has no corresponding <code>from</code> import).  After
the import, though, only the package or module following the <code>import</code> keyword
is added to the namespace of the importing module (as <code>module</code> objects,
renamed in the third case):</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">my_package</span> <span class="kn">import</span> <span class="n">foo</span>
<span class="kn">from</span> <span class="nn">my_package</span> <span class="kn">import</span> <span class="n">my_subpackage</span>
<span class="kn">from</span> <span class="nn">my_package</span> <span class="kn">import</span> <span class="n">my_subpackage</span> <span class="k">as</span> <span class="n">msp</span>
<span class="kn">from</span> <span class="nn">my_package.my_subpackage</span> <span class="kn">import</span> <span class="n">baz</span>
</pre></div>
<p>Imports using <code>from</code> can also be used to import particular attributes from the
namespaces of packages and modules.  For example, if the namespace of module
<code>foo</code> contains a variable <code>foo_var</code> then that variable can be imported with
this statement:</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">my_package.foo</span> <span class="kn">import</span> <span class="n">foo_var</span>
</pre></div>
<p>In fact, attributes inside package and module namespaces can <em>only</em> be imported
using a <code>from</code> import statement, never with a bare <code>import</code> statement.  This is
discussed further in the next subsection.</p>
</div>
<div class="section" id="possible-confusions-in-import-syntax">
<h3>3.3. <a class="toc-backref" href="#id7">Possible confusions in import syntax</a></h3>
<p>One possibly-confusing aspect of Python imports is that the dot symbol is
overloaded in Python’s syntax.  In Python expressions the dot is used for
attribute access, such as in <code>my_class.my_attribute</code>.  But in the dotted paths
of import statements the dot essentially means “subdirectory” and should be
thought of more as a “/” character in a pathname.  Import statements are an
exception in that they are the only statements where the dot syntax means
something other than attribute access.  In import statements the dot can <em>only</em>
be part of a dotted path.</p>
<p>Consider these valid import statements, assuming that <code>foo_var</code> is a variable
assigned in <code>foo.py</code>:</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">my_package</span> <span class="kn">import</span> <span class="n">foo</span> <span class="c1"># Works.</span>
<span class="kn">import</span> <span class="nn">my_package.foo</span> <span class="c1"># Works.</span>
</pre></div>
<p>After the second import above the statement <code>my_package.foo</code> is definitely
usable in Python expressions, as is <code>my_package.foo.foo_var</code>.  The latter is
valid because the initial module-scope attributes of <code>foo</code> are created when it
is imported and initialized, and they are also attributes of the corresponding
<code>module</code> object.</p>
<p>The first import above is essentially the same as the second one except that
the <code>module</code> object for <code>foo</code> is imported to the name <code>foo</code>.</p>
<p>Given the apparent pattern above the following may seem like it should work,
but it is not allowed:</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">my_package.foo</span> <span class="kn">import</span> <span class="n">foo_var</span> <span class="c1"># Works.</span>
<span class="kn">import</span> <span class="nn">my_package.foo.foo_var</span> <span class="c1"># FAILS!</span>
<span class="kn">import</span> <span class="nn">my_package.foo.foo_var</span> <span class="kn">as</span> <span class="nn">fv</span> <span class="c1"># Also FAILS!</span>
</pre></div>
<p>The first import works because <code>from</code> imports are allowed to import attributes
from the namespaces of packages and modules.  But the second import fails
because bare <code>import</code> statements cannot be used to import attributes from the
namespace of packages and modules.  Bare <code>import</code> statements can only be passed
dotted paths, which correspond to files and directories in the filesystem but
not things inside modules.  Renaming doesn’t change that, so the third import
also fails.  This holds even when the expression <code>my_package.foo.foo_var</code> is
usable in Python expressions.</p>
<p>Another thing you cannot do is assign Python variables as aliases to dotted
paths.  So, while it seems like it would be convenient, this code does not work:</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">my_package.foo</span> <span class="kn">as</span> <span class="nn">mpf</span> <span class="c1"># Works.</span>
<span class="kn">from</span> <span class="nn">mpf</span> <span class="kn">import</span> <span class="n">foo_var</span> <span class="c1"># FAILS! Only dotted paths directly after from statements.</span>
</pre></div>
<p>Although the attribute-access pattern of modules mimics the dotted-path
syntax, they are not the same thing.  The variable <code>mpf</code> is a reference
to the <code>module</code> object for <code>foo</code>.  It cannot be substituted for a dotted path.</p>
<p>Since references to module objects cannot be used in import statements, the full
dotted paths must always be entered.  Relative dotted paths, covered in the
next section, can simplify some cases of having to write out the full dotted paths.</p>
<p>To avoid these possible confusions, remember that dotted paths in Python import
statements always refer to filesystem objects (either directories or <code>.py</code>
files).  <strong>The first specifier in any import statement, whether a bare</strong>
<code>import</code> <strong>or a</strong> <code>from</code> <strong>import, can only be a dotted path</strong>.</p>
</div>
</div>
<div class="section" id="relative-imports">
<h2>4. <a class="toc-backref" href="#id8">Relative imports</a></h2>
<p>We saw in the previous section that dotted paths in absolute import statements
must always be typed out in full.  In the case of <strong>intra-package imports</strong>,
i.e., imports from subpackages and modules inside the same package, relative
imports can often be used to simplify the dotted-path expressions.  Keep in
mind that relative imports are <em>only</em> allowed for intra-package imports; all
other imports must use absolute imports.</p>
<p>Relative imports are to absolute imports as relative filename paths are to
absolute filename paths.  They allow for shortened expressions relative to
another directory.  First we will extend the definition of dotted paths to
allow for relative dotted paths.</p>
<div class="section" id="relative-dotted-paths">
<h3>4.1. <a class="toc-backref" href="#id9">Relative dotted paths</a></h3>
<p>A <strong>relative dotted path</strong> is similar to an absolute dotted path except that it
always starts with a dot symbol.</p>
<p>Relative dotted paths have different meanings depending on the location of the
module in which they occur.  They are interpreted relative to the directory
containing the module in which they occur.  (If you are familiar with relative
paths in a Unix-style shell such as Bash, the syntax is similar.)</p>
<ul class="simple">
<li>A single dot refers to the directory containing the module.  It can occur
alone or at the beginning of a longer dotted path.  As an example, the
following correspondences hold inside the <code>foo</code> module (located in directory
<code>my_package</code>).  The first two are equivalent filesystem paths relative to
directory <code>src/my_package</code>, and the last one is the Python dotted path.
(Note in the second line that while <code>bar</code> without the dot is also an
equivalent relative pathname in a shell, as a dotted path it is <em>only</em>
allowed as a top-level absolute import from <code>sys.path</code>.)</li>
</ul>
<div class="math">
\begin{align*}
\scriptstyle\texttt{my_package} \;\Longleftrightarrow\;\; \texttt{.} \;\;\Longrightarrow\; \texttt{.} \\
\end{align*}
</div>
<div class="math">
\begin{align*}
\scriptstyle\texttt{my_package/bar.py} \;\Longleftrightarrow\; \texttt{./bar.py} \;\Longrightarrow\; \texttt{.bar} \\
\end{align*}
</div>
<div class="math">
\begin{align*}
\scriptstyle\texttt{my_package/my_subpackage/baz.py} \;\Longleftrightarrow\; \texttt{./my_subpackage/baz.py} \;\Longrightarrow\; \texttt{.my_subpackage.baz} \\
\end{align*}
</div>
<ul class="simple">
<li>Two dots refer to the parent directory of the directory containing the
module.  They can occur alone or at the beginning of a longer dotted path.
The following correspondence holds inside the <code>baz</code> module (which is located
in directory <code>my_subpackage</code>).  The first two are equivalent filesystem paths
relative to directory <code>src/my_package/my_subpackage</code> and the last one is the
Python dotted path:</li>
</ul>
<div class="math">
\begin{align*}
\scriptstyle\texttt{my_package} \;\Longleftrightarrow\;\; \texttt{..} \;\;\Longrightarrow\; \texttt{..} \\
\end{align*}
</div>
<div class="math">
\begin{equation*}
\scriptstyle\texttt{my_package/bar.py} \;\Longleftrightarrow\; \texttt{my_package/my_subpackage/../bar.py} \;\Longrightarrow\; \texttt{..bar}
\end{equation*}
</div>
<ul class="simple">
<li>Each additional dot goes up one more directory level.</li>
</ul>
<p>Suppose there were another subpackage named <code>sibling</code> at the same level as
<code>my_subpackage</code>.  Then a module <code>cousin</code> in it could be imported from <code>baz</code> by
going up and then down as follows:</p>
<div class="math">
\begin{equation*}
\scriptstyle\texttt{my_package/sibling/cousin} \;\Longrightarrow\; \texttt{..sibling.cousin}
\end{equation*}
</div>
</div>
<div class="section" id="id1">
<h3>4.2. <a class="toc-backref" href="#id10">Relative imports</a></h3>
<p>Now that relative dotted paths have been covered, relative imports are
straightforward: just use a relative dotted path instead of an absolute dotted
path (but remember that they are only allowed for intra-package imports).</p>
<p>There is another important restriction on relative imports: <strong>A relative dotted
path can only appear after a</strong> <code>from</code> <strong>statement.</strong>  It seems like you should
be able to write imports such as <code>import .bar</code> from the <code>foo</code> module and
<code>import ..bar</code> from <code>baz</code> module, but those are syntax errors.  The reason this
is not allowed is that the relative dotted paths (such as <code>.bar</code>) after bare
<code>import</code> statements are not valid Python names and therefore cannot be used in
Python expressions as attribute accesses.</p>
<p>The following are valid relative imports from the <code>foo</code> module:</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">bar</span>
<span class="kn">from</span> <span class="nn">.bar</span> <span class="kn">import</span> <span class="n">bar_var</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">my_subpackage</span>
<span class="kn">from</span> <span class="nn">.my_subpackage</span> <span class="kn">import</span> <span class="n">baz</span>
<span class="kn">from</span> <span class="nn">.my_subpackage.baz</span> <span class="kn">import</span> <span class="n">baz_var</span>
</pre></div>
<p>These relative imports are all valid in the <code>baz</code> module:</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">bar</span>
<span class="kn">from</span> <span class="nn">..bar</span> <span class="kn">import</span> <span class="n">bar_var</span>
</pre></div>
<p>In addition to importing modules and subpackages from the specified directory,
<code>from</code> imports using only-dot paths such as <code>.</code> and <code>..</code> can also be used to
import attributes from package and subpackage namespaces (i.e., from
<code>__init__.py</code> namespaces)  For example, this import from module <code>foo</code> would
import the variable <code>init_var</code> defined in module <code>my_package.__init__.py</code>:</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">init_var</span>
</pre></div>
</div>
</div>
<div class="section" id="imports-in-scripts">
<h2>5. <a class="toc-backref" href="#id11">Imports in scripts</a></h2>
<p>A <strong>script</strong> is any Python module which is directly run by the Python
interpreter.  This can be done from the command line with the <code>python</code> command,
by clicking an icon, or via some other invocation method such as from a menu.
Python applications are usually started by running a Python module
as a script.</p>
<p>Scripts have a few unique properties not shared by other modules:</p>
<ol class="arabic simple">
<li>The directory containing the script file is automatically inserted to
<code>sys.path[0]</code> when the script is run by the Python interpreter.   The
absolute directory path is always added; the current working directory, in
the shell or in Python, has no effect on this.</li>
<li>The <code>__name__</code> attribute of the script’s module is always set to
<code>"__main__"</code> when it is run as a script, regardless of the file’s name.</li>
<li>By default a script is not run as part of a package, even if there happens
to be an <code>__init__.py</code> in its directory.</li>
</ol>
<p>Property 1 allows a script to import any package or module which is located in
its directory as an absolute, non-dotted import.  This is helpful if the
directory contains top-level packages or standalone modules that are intended
to be imported.  In some situations this can cause problems such as unintended
imports due to name shadowing and importing modules inside packages as if they
were standalone modules.</p>
<p>Property 2 is what allows the use of this common idiom in Python scripts:</p>
<div class="highlight"><pre><span></span><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">"__main__"</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span> <span class="c1"># A commonly-seen example, running function `main`.</span>
</pre></div>
<p>Code in that conditional block only executes when the module is directly run as
a script and not when the module is imported from another Python module (some
modules are meant to be used both ways).</p>
<div class="section" id="scripts-outside-of-packages">
<h3>5.1. <a class="toc-backref" href="#id12">Scripts outside of packages</a></h3>
<p>The standard idiom for Python scripts is that they should be located outside of
packages.  The script can then load any packages or modules it needs.  There
are some use cases for scripts inside packages, which will be covered in the
subsection after this one.</p>
<p>The rule for imports in scripts located outside packages is simple: scripts
outside packages can only use absolute imports.  Any absolute imports are
allowed, but of course modules inside packages should almost always be imported
as part of their package, using the dotted-path syntax relative to their
package root, rather than as a non-dotted import.  In some cases
it may be necessary to insert elements to <code>sys.path[1]</code> (after the current
directory at <code>sys.path[0]</code>) in order for Python to discover the necessary
modules and packages to import.</p>
<p>If you use a <code>setup.py</code> for your project then scripts outside packages <a class="reference external" href="https://python-packaging.readthedocs.io/en/latest/command-line-scripts.html">can be
added to a project</a>
by using the <code>scripts</code> keyword argument.  For development this involves setting
up the project with a <code>setup.py</code> and then installing the project in development
mode, such as by running <code>pip install -e .</code> in the directory with <code>setup.py</code>.
(The <code>setup.py</code> file is usually placed in the project’s root directory, which
is <code>my_project</code> in the project skeleton given earlier).  This provides a shell
command for running the script which is in the shell search path.  To add or
remove scripts from the project the <code>setup.py</code> must be modified and the package
reinstalled.  A similar thing can be done using the more-recent
<code>pyproject.toml</code> files if you use that method to set up projects rather than
using a <code>setup.py</code>.</p>
</div>
<div class="section" id="scripts-inside-packages">
<h3>5.2. <a class="toc-backref" href="#id13">Scripts inside packages</a></h3>
<p>Scripts can also be run inside packages, but the special properties of scripts
listed above have some side-effects which need to be taken into account.</p>
<p>Property 3 means that the package the script is inside of is not automatically
imported when the script runs.  To import modules from the package the script
can only use non-dotted absolute imports (based on Property 1).  This only
works correctly in simple cases where the imported modules are essentially
standalone modules themselves.  Even if the script itself imports the full
package in the usual way the running script is still not correctly set up as a
module of the package.</p>
<p>If the script does explicitly import its containing package then dotted
absolute imports from the package will work.  But the script module itself
should never be imported by any other module in the package since it is cached
as the <code>__main__</code> module by Property 2 and a double import will result.</p>
<p>To get around these problems and correctly run scripts inside packages what is
needed is a way to automatically import the containing package and then run the
script as a part of the package.  There are several possible ways to do this:</p>
<ol class="arabic simple">
<li>Invoke the script using <code>python -m &lt;fullyQualifiedName&gt;</code>, where
<code>&lt;fullyQualifiedName&gt;</code> is the fully-qualified name of the module inside the
package (i.e., the absolute dotted path).  Note that the directory
containing the top-level package directory must be in <code>sys.path</code> or the
command will fail.  You could write a shell script wrapper for the <code>python</code>
command to modify <code>PYTHONPATH</code>, calculate the qualified name, and then
invoke <code>python -m</code>.  Generally, though, the invocation differs from that of
other Python scripts.</li>
<li>Set the <code>__package__</code> attribute of the script to the fully-qualified name
and then import the package in the correct way.  This is more complex than
you might expect, but fortunately there is a <a class="reference external" href="https://abarker.github.io/set-package-attribute/">package on PyPI</a> which can do this for
you automatically (and optionally also remove the directory’s <code>sys.path</code>
entry).</li>
<li>Create a <code>setup.py</code> file and <a class="reference external" href="http://www.python.org/">create an entry point</a> for the script via the <code>console_scripts</code> keyword.
(This is similar to the <code>scripts</code> keyword described above, but it allows
modules inside packages to be run via an entry-point function.)  To add or
remove entry points the <code>setup.py</code> file must be modified and the package
reinstalled.  This creates commands which are directly executable in the
shell, under the name specified in <code>setup.py</code>.</li>
</ol>
</div>
</div>
<div class="section" id="not-covered">
<h2>6. <a class="toc-backref" href="#id14">Not covered</a></h2>
<p>This article has covered the basics of the Python import system, but some
important topics have not been discussed.  They tend to occur or be used in
special or advanced cases.</p>
<p><strong>Star imports</strong>: By default, the statement <code>from my_module import *</code> imports
all the names in the <code>my_module</code> namespace which do not start with the
underscore character.  If <code>__all__</code> is defined in <code>my_module</code> as a list of
string variable names then <code>*</code>-imports from the module will only import those
names.  Anything else would need to be explicitly imported.  The <code>__all__</code> list
for an <code>__init__.py</code> file can also contain the names of modules and subpackages
to import: a <code>*</code>-import of the corresponding package or subpackage will then
implicitly perform the imports (which need to be done explicitly for ordinary modules).</p>
<p><strong>Circular imports</strong>:  This problem can arise when one module imports another
module which then imports the first module again.  The usual solution is to
reorganize the module structure or to put the problematic import inside a
function so it is not performed on module initialization.  Circular imports are
discussed in the answer to this Python <span class="caps">FAQ</span> question: “<a class="reference external" href="https://docs.python.org/3/faq/programming.html#what-are-the-best-practices-for-using-import-in-a-module">What are the ‘best
practices’ for using import in a module?</a>”</p>
<p id="namespace-packages"><strong>Namespace packages</strong>: Namespace packages allow one or more toplevel
directories having the same directory name, but without <code>__init__.py</code> files, to
be used like a common namespace for all the modules and packages across all the
directories (which must all be discoverable on <code>sys.path</code>).  This can be useful
for large distributions, but there are also drawbacks such as the lack of
<code>__init__.py</code> files.  Most people should continue to use <code>__init__.py</code> files to
create single-directory packages.</p>
<p><strong>pth files</strong>: Pth files are special files which contain the pathnames of
packages or modules to import.  Using pth files only works when they are placed
in the special system <code>site-packages</code> directory.</p>
<p><strong>Importing from zip files</strong>: Python allows modules to be imported from
zipfiles, provided the <code>.zip</code> archive file is located on <code>sys.path</code>.   The
directory structure in the zip file then acts as a regular directory.</p>
<p><strong>Lower-level APIs of the import system</strong>:  The <a class="reference external" href="https://docs.python.org/3/reference/import.html">full Python import system</a> is complicated and
customizable.  There are protocols to allow it to be dynamically modified in
various ways for special applications.</p>
</div>
<div class="section" id="further-reading">
<h2>7. <a class="toc-backref" href="#id15">Further reading</a></h2>
<ul class="simple">
<li>The official Python documentation on <a class="reference external" href="https://docs.python.org/3/reference/import.html">imports</a> and
<a class="reference external" href="https://docs.python.org/3.7/tutorial/modules.html">modules</a>.</li>
<li>A detailed <a class="reference external" href="https://chrisyeh96.github.io/2017/08/08/definitive-guide-python-imports.html">guide to Python imports</a> by Chris Yeh.</li>
<li>An <a class="reference external" href="https://realpython.com/absolute-vs-relative-python-imports">introduction to absolute vs. relative imports</a>, including a discussion
of formatting style.   By Mbithe Nzomo.</li>
<li>A discussion of some of the often subtle <a class="reference external" href="http://python-notes.curiousefficiency.org/en/latest/python_concepts/import_traps.html">import traps</a>
which can arise, by Nick Coghlan.</li>
</ul>
</div>
<script type='text/javascript'>if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (true) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js','color.js','AMSmath.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'black ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>
            <div>
</div>

            
            <section>
<p id="comment-message">Leave any comments below. </p>
<div class="accordion" id="accordion2">
    <div class="accordion-group">
        <div class="accordion-heading">
            <a class="accordion-toggle disqus-comment-count" data-toggle="collapse" data-parent="#accordion2"
                href="https://abarker.github.io/understanding_python_imports/#disqus_thread",
                id="disqus-accordion-toggle">
                Comments
            </a>
        </div>
        <div id="disqus_thread" class="accordion-body collapse">
            <div class="accordion-inner">
                <div class="comments">
                    <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'abarker';
        var disqus_identifier = 'https://abarker.github.io/understanding_python_imports/';
    var disqus_url = 'https://abarker.github.io/understanding_python_imports/';

    (function() {
         var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
         dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
         (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
     })();
</script>
<noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

                </div>
            </div>
        </div>
    </div>
</div>
</section>

            <hr/>
            <aside>
            <nav>
            <ul class="articles-timeline">
                <li class="next-article"><a href="https://abarker.github.io/setting_up_vim_spellchecking/" title="Next: Setting Up Spellchecking in Vim">Setting Up Spellchecking in Vim</a> »</li>
            </ul>
            </nav>
            </aside>
        </div>
        <section>
        <div class="span2" style="float:right;font-size:0.9em;">
            <h4>Published</h4>
            <time itemprop="dateCreated" datetime="2019-07-12T14:13:00-04:00">Jul 12, 2019</time>

<h4>Last Updated</h4>
<time datetime="2019-07-12T14:13:00-04:00">Jul 12, 2019</time>

            <h4>Category</h4>
            <a class="category-link" href="https://abarker.github.io/categories.html#programming-ref">programming</a>
            <h4>Tags</h4>
            <ul class="list-of-tags tags-in-article">
                <li><a href="https://abarker.github.io/tags#programming-ref">programming
                    <span>1</span>
</a></li>
                <li><a href="https://abarker.github.io/tags#python-ref">python
                    <span>1</span>
</a></li>
            </ul>
<h4>Contact</h4>
    <a href="http://github.com/abarker" title="My Github Profile" class="sidebar-social-links" target="_blank">
    <i class="fa fa-github sidebar-social-links"></i></a>
    <a href="mailto:Allen.L.Barker@gmail.com" title="My Email Address" class="sidebar-social-links" target="_blank">
    <i class="fa fa-envelope sidebar-social-links"></i></a>
        </div>
        </section>
</div>
</article>
                </div>
                <div class="span1"></div>
            </div>
        </div>
        <div id="push"></div>
    </div>
<footer>
<div id="footer">
    <ul class="footer-content">
        <li class="elegant-power">Powered by <a href="http://getpelican.com/" title="Pelican Home Page">Pelican</a>. Theme: <a href="https://github.com/Pelican-Elegant/elegant/" title="Theme Elegant Home Page">Elegant</a></li>
    </ul>
</div>
</footer>            <script src="//code.jquery.com/jquery.min.js"></script>
        <script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js"></script>
        <script>
            function validateForm(query)
            {
                return (query.length > 0);
            }
        </script>

            <script type="text/javascript">
var disqus_shortname = 'abarker';
(function () {
    var s = document.createElement('script'); s.async = true;
    s.type = 'text/javascript';
    s.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
}());
</script>
<script  language="javascript" type="text/javascript">
function uncollapse() {
    if (window.location.hash.match(/^#comment-\d+$/)) {
        $('#disqus_thread').collapse('show');
    }
}
</script>
<script type="text/javascript" language="JavaScript">
uncollapse();
window.onhashchange=function(){
    if (window.location.hash.match(/^#comment-\d+$/))
        window.location.reload(true);
}
</script>
<script>
$('#disqus_thread').on('shown', function () {
    var link = document.getElementById('disqus-accordion-toggle');
    var old_innerHTML = link.innerHTML;
    $(link).fadeOut(500, function() {
        $(this).text('Click here to hide comments').fadeIn(500);
    });
    $('#disqus_thread').on('hidden', function () {
        $(link).fadeOut(500, function() {
            $(this).text(old_innerHTML).fadeIn(500);
        });
    })
})
</script>


    </body>
    <!-- Theme: Elegant built for Pelican
    License : MIT -->
</html>